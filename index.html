<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D 粒子系統 - 水果與形狀版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; color: white; }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #video-input { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
        }
        button {
            padding: 20px 40px; font-size: 20px; cursor: pointer; background: #ffcc00;
            border: none; border-radius: 40px; color: #000; font-weight: bold;
        }
    </style>
</head>
<body>

<div id="loading-screen" class="overlay">
    <h2 style="margin: 0;">3D 粒子系統</h2>
    <p style="color: #888; margin: 10px 0 30px 0;">手勢控制：兩手拉開=放大 / 合攏=縮小</p>
    <button id="start-btn">開始體驗</button>
</div>

<video id="video-input" playsinline muted autoplay></video>
<div id="container"></div>

<!-- 引用 JS 庫 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.9/dist/tweakpane.min.js"></script>

<script>
    let scene, camera, renderer, particles, geometry;
    let targetPositions = []; 
    const PARTICLE_COUNT = 3500;
    const params = {
        template: 'heart',
        color: '#ff3366',
        expansion: 1.0,
        morphSpeed: 0.06
    };

    // --- 核心算法：生成各種形狀的粒子座標 ---
    function generateShape(type) {
        const arr = new Float32Array(PARTICLE_COUNT * 3);
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x=0, y=0, z=0;
            
            if (type === 'heart') { // 愛心
                const t = Math.random() * Math.PI * 2;
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random() - 0.5) * 3;
            } 
            else if (type === 'flower') { // 花朵
                const t = (i / PARTICLE_COUNT) * Math.PI * 20;
                const r = 12 * Math.sin(2.5 * t);
                x = r * Math.cos(t);
                y = r * Math.sin(t);
                z = (Math.random() - 0.5) * 2;
            } 
            else if (type === 'fireworks') { // 煙火 (隨機球體)
                const r = 10 + Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            }
            else if (type === 'banana') { // 香蕉 (弧形)
                const t = (Math.random() - 0.5) * 2.5; // 彎曲度
                const r = 10;
                const sectionR = 2 + Math.random(); // 香蕉粗度
                const angle = Math.random() * Math.PI * 2;
                x = r * Math.cos(t) + sectionR * Math.cos(angle);
                y = r * Math.sin(t) + sectionR * Math.sin(angle);
                z = sectionR * Math.sin(angle) * 0.5;
                // 旋轉一下讓它看起來像橫放的香蕉
                let temp = x; x = y; y = -temp;
            }
            else if (type === 'peach') { // 蜜桃 (帶溝的球體)
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                // 蜜桃表面的數學微調 (在某些角度縮排形成溝槽)
                const dent = 0.8 + 0.2 * Math.abs(Math.sin(phi));
                const r = 12 * dent * Math.sin(theta);
                x = r * Math.cos(phi);
                y = 12 * Math.cos(theta); // 高度
                z = r * Math.sin(phi);
                // 頂部尖尖的效果
                if (y > 8) { x *= 0.5; z *= 0.5; }
            }

            arr[i*3] = x * 0.8;
            arr[i*3+1] = y * 0.8;
            arr[i*3+2] = z * 0.8;
        }
        return arr;
    }

    // --- 初始化 Three.js ---
    function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        geometry = new THREE.BufferGeometry();
        const startPos = generateShape('heart');
        targetPositions = new Float32Array(startPos);
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(startPos), 3));

        const material = new THREE.PointsMaterial({
            color: new THREE.Color(params.color),
            size: 0.45,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 控制面板
        const pane = new Tweakpane.Pane({ title: '選單', expanded: true });
        pane.addInput(params, 'template', {
            options: { 愛心: 'heart', 花朵: 'flower', 煙火: 'fireworks', 香蕉: 'banana', 蜜桃: 'peach' },
            label: '選擇形狀'
        }).on('change', (ev) => {
            targetPositions = generateShape(ev.value);
            // 根據形狀自動換個顏色
            if(ev.value === 'banana') params.color = '#ffff00';
            if(ev.value === 'peach') params.color = '#ffb7b7';
            if(ev.value === 'flower') params.color = '#ff66ff';
            pane.refresh();
        });
        pane.addInput(params, 'color', { label: '調整顏色' });
    }

    // --- MediaPipe 邏輯 ---
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5 });
    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length >= 2) {
            const h1 = results.multiHandLandmarks[0][9];
            const h2 = results.multiHandLandmarks[1][9];
            const dist = Math.sqrt(Math.pow(h1.x-h2.x, 2) + Math.pow(h1.y-h2.y, 2));
            params.expansion = 0.5 + (dist * 5.0);
        } else {
            params.expansion = THREE.MathUtils.lerp(params.expansion, 1.0, 0.1);
        }
    });

    const videoElement = document.getElementById('video-input');
    document.getElementById('start-btn').addEventListener('click', async () => {
        try {
            const cam = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 480, height: 640
            });
            await cam.start();
            document.getElementById('loading-screen').style.display = 'none';
            initThree();
            animate();
        } catch (e) { alert("無法開啟相機: " + e.message); }
    });

    function animate() {
        requestAnimationFrame(animate);
        
        // 形狀平滑過渡
        const positions = geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i++) {
            positions[i] += (targetPositions[i] - positions[i]) * params.morphSpeed;
        }
        geometry.attributes.position.needsUpdate = true;

        particles.rotation.y += 0.005;
        particles.scale.set(params.expansion, params.expansion, params.expansion);
        particles.material.color.set(params.color);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
